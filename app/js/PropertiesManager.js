'use strict';
/** @jsx h */
import { Component, h } from 'preact';

import CONST from './enums/CONST';
import PROPERTY_TYPES from './enums/PROPERTY_TYPES';
import Property from './do/Property';
import md5 from 'md5';

/* example component to start from */
class PropertiesManager extends Component {
  constructor(props) {
    super(props);

    this.state = {
      selectedProperty: null,
      entity: props.entity
    };
  }

  componentWillReceiveProps(nextProps) {
    this.setState({
      entity: nextProps.entity,
      selectedProperty: null
    });
  }

  componentWillUpdate(props, state) {
    this.props.onEntityChange(state.entity);
  }

  selectProperty(prop) {
    isShowPropertyEditor('flex');
    this.setState({ selectedProperty: prop });
  }

  addProperty() {
    const entity = this.state.entity;
    entity.properties.push(new Property());
    this.setState({ entity });
  }

  addPropertyByData(data) {
    const entity = this.state.entity;
    const pros = entity.properties;
    let mark = 0;
    for (const mp of pros) {
      if (mp.key === data.key) {
        mark = 1;
        break;
      }
    }
    if (mark === 0) {
      entity.properties.push(new Property(data));
      this.setState({ entity });
    }
  }

  changePropertyName(e, prop) {
    prop.key = e.target.value;
  }

  deleteProperty(prop) {
    const entity = this.state.entity;
    const selectedProperty = this.state.selectedProperty;
    entity.properties = entity.properties.filter((property) => property.id !== prop.id);

    if (selectedProperty && selectedProperty.id === prop.id) {
      this.setState({ selectedProperty: null });
    }

    this.setState({ entity });
  }

  render(props, state) {
    const entity = state.entity;
    const typesWithLimit = [PROPERTY_TYPES.STRING, PROPERTY_TYPES.INT, PROPERTY_TYPES.FLOAT, PROPERTY_TYPES.URL, PROPERTY_TYPES.EMAIL, PROPERTY_TYPES.PASSWORD];
    const textTypes = [PROPERTY_TYPES.STRING, PROPERTY_TYPES.URL, PROPERTY_TYPES.EMAIL, PROPERTY_TYPES.PASSWORD];

    if (!entity) {
      return <div className="no-selected">Select node/edge to edit properties</div>;
    }
    return <div id={CONST.PROPERTY_MENU_ID} className={CONST.PROPERTY_MENU_CLASS}>
      <div className="header">
        <span className="color">
          <input id="entity-color" value={entity.color} onInput={ this.linkState('entity.color')} type="color" />
        </span>
        <span className="label">
          <input id="entity-label" value={entity.label} onInput={ this.linkState('entity.label') }/>
          <small className="type">{entity.isNode && 'node' || entity.isEdge && 'edge'}</small>
        </span>
        <button className="add-button" onClick={ this.addProperty.bind(this) }>+ Add property</button>
      </div>
      <div className="main">
        <div id="properties-search">
          <p>
            <input type="text" name="" id="properties-search-input" placeholder="Search properties" onInput={ this.searchData.bind(this) } />
          </p>
          <ul id="properties-search-result" onClick={ this.searchResultClick() } />
        </div>
        <div className="properties">
          <ul id="properties-list">
            { entity.properties.map((prop) => <li className={{
              selected: (state.selectedProperty && prop.id === state.selectedProperty.id),
              disabled: prop.isSystem,
              schema_indexes: prop.key === 'schema-indexes'
            }}>
              <div className="property">
                <input
                    type="text"
                    className="propertyName"
                    value={prop.key}
                    onInput={ (e) => this.changePropertyName(e, prop) }
                    onClick={this.selectProperty.bind(this, prop)}
                    disabled={prop.isSystem}
                />
                <small className="type">{prop.type}{prop.isRequired ? '!' : ''}{prop.isAutoGenerated ? '@' : ''}</small>
                &nbsp;
              </div>
              <div className="remove-property-button" title="Delete" onClick={ this.deleteProperty.bind(this, prop) }>
                x
              </div>
            </li>)
            }
          </ul>
        </div>
        { state.selectedProperty &&
        <div className="property-edit" id="property-edit">
          <ul>
            <li>
              <label>
                <span>type:</span>
                <select value={ state.selectedProperty.type } onChange={ this.linkState('selectedProperty.type') }>
                  {
                    Object.keys(PROPERTY_TYPES).map((type) => <option
                        value={PROPERTY_TYPES[type]}>{PROPERTY_TYPES[type]}</option>)
                  }
                </select>
              </label>
            </li>
            { !state.selectedProperty.isAutoGenerated &&
            <li>
              <label>
                <span title="Property's default value">Default:</span>
                <input
                    className="defaultValue"
                    value={ state.selectedProperty.defaultValue }
                    onInput={ this.linkState('selectedProperty.defaultValue') }
                />
              </label>
            </li>
            }
            <li>
              <label>
                <span title="Is the property required">Required:</span>
                <input
                    className="isRequired"
                    type="checkbox"
                    checked={ state.selectedProperty.isRequired }
                    onClick={ this.linkState('selectedProperty.isRequired') }
                />
              </label>
            </li>
            <li>
              <label>
                <span title="Auto generated">Auto gen.:</span>
                <input
                    className="isRequired"
                    type="checkbox"
                    checked={ state.selectedProperty.isAutoGenerated }
                    onClick={ this.linkState('selectedProperty.isAutoGenerated') }
                />
              </label>
            </li>

            { (typesWithLimit.indexOf(state.selectedProperty.type) !== -1) &&
            <li>
              <label>
                <span>min{ textTypes.indexOf(state.selectedProperty.type) !== -1 ? ' len.' : '' }:</span>
                <input
                    className="limitMin"
                    type="number"
                    min="0"
                    max="100000"
                    value={state.selectedProperty.limitMin}
                    onInput={ this.linkState('selectedProperty.limitMin') }
                />
              </label>
              <label>
                <span>max{ textTypes.indexOf(state.selectedProperty.type) !== -1 ? ' len.' : '' }:</span>
                <input
                    className="limitMin"
                    type="number"
                    min="0"
                    max="100000"
                    value={state.selectedProperty.limitMax}
                    onInput={ this.linkState('selectedProperty.limitMax') }
                />
              </label>
            </li>
            }
          </ul>
          <div className="propertyDescription">
            <label>
              <span>Description:</span>
              <input
                  value={state.selectedProperty.description}
                  onInput={ this.linkState('selectedProperty.description') }
              />
            </label>
          </div>
        </div>
        }
      </div>
    </div>;
  }

  searchData() {
    const entity = this.state.entity;
    isShowPropertyEditor('none');
    $(function () {
      $('#properties-search-input').on('input', function () {
        search($(this).val(), entity);
        // 刷新缓存
        refreshCache();
      });
    });
  }

  searchResultClick() {
    const element = document.getElementById('properties-search-result');
    if (element !== null) {
      element.addEventListener('click', (e) => {
        const target = e.target;
        const data = searchMap.get(target.id);
        this.addPropertyByData(data);
      });
    }
  }
}

/**
 * @param value:属性值
 * @description 控制属性编辑器隐藏或显示
 */
function isShowPropertyEditor(value) {
  const ele = document.getElementById('property-edit');
  if (ele !== null) {
    ele.style.display = value;
  }
}

const localStorageItem = 'nma.grad3ph';
const localStorageItemSaves = 'nma.grad3ph.saves';
let searchList = searchData(JSON.parse(localStorage.getItem(localStorageItem)), JSON.parse(localStorage.getItem(localStorageItemSaves)));

/**
 * @description 刷新缓存数据
 */
function refreshCache() {
  searchList = searchData(JSON.parse(localStorage.getItem(localStorageItem)), JSON.parse(localStorage.getItem(localStorageItemSaves)));
}

/**
 * @param localStorageItem：当前数据
 * @param localStorageItemSaves：缓存的历史数据
 * @description 封装搜索数据
 * @returns {string}
 * @private
 */
function searchData(localStorageItem, localStorageItemSaves) {
  console.log(localStorageItem);
  console.log(localStorageItemSaves);
  localStorageItemSaves.push({ data: localStorageItem });
  const data = [];
  const mapDuplicate = {};
  for (const lst of localStorageItemSaves) {
    const nodes = lst.data.nodes;
    const edges = lst.data.edges;
    // 处理节点、关系属性
    for (const list of [nodes, edges]) {
      for (const mp of list) {
        const pros = mp.properties;
        for (const pr of pros) {
          const ele = {
            search: (pr.key + pr.type + pr.defaultValue + pr.description).toLowerCase(),
            key: pr.key,
            type: pr.type,
            defaultValue: pr.defaultValue,
            limitMin: pr.limitMin,
            limitMax: pr.limitMax,
            isRequired: pr.isRequired,
            isAutoGenerated: pr.isAutoGenerated,
            description: pr.description
          };
          const dumpID = md5(ele.search);
          if (!mapDuplicate.hasOwnProperty(dumpID)) {
            data.push(ele);
            mapDuplicate[dumpID] = 1;
          }
        }
      }
    }
  }
  return data;
}

// 页面元素ID与数据的绑定MAP
const searchMap = new Map();

/**
 * @param key:属性KEY
 * @param properties:当前选中实体拥有的属性
 * @returns {string}
 * @private
 */
function containsKey(key, properties) {
  for (const mp of properties) {
    if (mp.key === key) {
      return false;
    }
  }
  return true;
}

/**
 * @param valRaw:输入的搜索串
 * @param currentEntity:当前选中的实体
 * @returns {string}
 * @private
 */
function search(valRaw, currentEntity) {
  // 获取ul
  const oul = document.getElementById('properties-search-result');
  // 清空ul里面的内容
  searchMap.clear();
  oul.innerHTML = '';

  // 定义新数组，保存符合搜索内容要求的数据
  const a = [];
  let k = 0;

  // 循环判断符合要求的数据
  const val = valRaw.toLowerCase().trim();
  if (val !== '') {
    for (let j = 0; j < searchList.length; j ++) {
      const mp = searchList[j];
      if (containsKey(mp.key, currentEntity.properties)) { // 数据中不包含搜索内容值的返回-1
        if (mp.search.indexOf(val) !== -1) {
          a[k++] = { show: mp.key.concat('|', mp.type, '|', mp.defaultValue, '|', mp.description, '|'), data: mp };
        }
      }
    }

    // 按照搜索串的长度升序排序
    a.sort(function (a, b) {
      return a.show.length - b.show.length;
    });

    // 循环将数据输出到ul下
    for (let p = 0; p < a.length; p ++) {
      // 创建li
      const oli = document.createElement('li');
      // 定义li里的内容
      oli.innerHTML = a[p].show;
      // 将li添加到ul里
      oul.appendChild(oli);

      // 添加点击事件
      oli.className = 'li';
      const id = 'properties-search-result-'.concat(p);
      oli.id = id;
      searchMap.set(id, a[p].data);
      if (p > 10) {
        break;
      }
    }
  }
}

export default PropertiesManager;
