'use strict';

import DataManager from '../DataManager';
import createId from '../utils/id.js';
import geometry from '../utils/geometry';

import Property from './Property';
import PROPERTY_TYPES from '../enums/PROPERTY_TYPES';
import color from '../utils/color';
import StyleManager from '../style/StyleManager';

function setColor(options) {
  const startNode = DataManager.getNode(options.startNodeId);
  if (options.color !== undefined || startNode !== undefined) {
    return options.color || startNode.color;
  }
  return color();
}

function setPathStrokeDasharray(options) {
  if (options.pathStrokeDasharray !== undefined) {
    return options.pathStrokeDasharray;
  }
  return StyleManager.getPathStrokeDasharray();
}

class Edge {
  /**
   * @param {object} options
   * @param {number} options.startNodeId
   * @param {number} options.endNodeId
   * @param {array} options.middlePointOffset
   * @param {string} options.label
   * @param {array} options.properties
   * @param {string} options.id
   * @constructor
   */
  constructor(options = {}) {
    const idPropertyConfig = { key: 'id', isRequired: true, type: PROPERTY_TYPES.ID, isAutoGenerated: true, isSystem: true };
    const idProperty = new Property(idPropertyConfig);

    const indexesPropertyConfig = { key: 'schema-indexes', isRequired: false, type: PROPERTY_TYPES.STRING, isAutoGenerated: false, isSystem: false, defaultValue: '//CONSTRAINT AND INDEX：\n' +
          '//CONSTRAINT:CREATE CONSTRAINT ON (n:Label) ASSERT n.code IS UNIQUE;\n' +
          '//CONSTRAINT:CREATE CONSTRAINT ON (n:Label) ASSERT (n.name,n.code) IS NODE KEY;\n' +
          '//INDEX:CREATE INDEX ON :Label(name);\n' +
          '//INDEX:CREATE INDEX ON :Label(name,hupdatetime);\n' +
          '//DROP:DROP CONSTRAINT ON (n:Label) ASSERT (n.name,n.code) IS NODE KEY;\n' +
          '//DROP:DROP INDEX ON :Label(name)' };
    const indexesProperty = new Property(indexesPropertyConfig);

    this.startNodeId = options.startNodeId;
    this.endNodeId = options.endNodeId;
    this.middlePointOffset = options.middlePointOffset || [0, 0];
    this.properties = options.properties || [idProperty, indexesProperty];
    // 取消默认转小写操作
    // this.label = (options.label || 'no name').toLowerCase();
    this.label = (options.label || 'no name');
    this.id = options.id || createId();
    this.isSelected = options.isSelected || false;
    this.isEdge = true;
    // this.color = options.color || this.startNode.color;
    this.color = setColor(options);
    this.pathStrokeDasharray = setPathStrokeDasharray(options);
  }

  get copy() {
    return new Edge((JSON.parse(JSON.stringify(this))));
  }

  get startNode() {
    return DataManager.getNode(this.startNodeId);
  }

  get endNode() {
    return DataManager.getNode(this.endNodeId);
  }

  /**
   * @returns {Array}
   */
  get middlePoint() {
    return geometry.middlePoint(this.startNode, this.endNode);
  }

  get middlePointWithOffset() {
    if (this.startNodeId === this.endNodeId && this.middlePointOffset[0] === 0 && this.middlePointOffset[1] === 0) {
      this.middlePointOffset = [-50, 50];
    }

    return [
      this.middlePoint[0] - this.middlePointOffset[0],
      this.middlePoint[1] - this.middlePointOffset[1]
    ];
  }
}

export default Edge;
